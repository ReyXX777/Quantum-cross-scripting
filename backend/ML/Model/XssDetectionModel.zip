using Microsoft.AspNetCore.Mvc;
using Microsoft.ML;
using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Threading.Tasks;

namespace QuantumCrossScripting.ML.Model
{
    // The model input class
    public class XssDetectionModelInput
    {
        public string InputText { get; set; }
    }

    // The model output class
    public class XssDetectionModelOutput
    {
        public bool IsMalicious { get; set; }
    }

    [ApiController]
    [Route("[controller]")]
    public class XssDetectionController : ControllerBase
    {
        private readonly string _modelPath = "ML/Model/XssDetectionModel.zip"; // Model path (could be configurable)
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private PredictionEngine<XssDetectionModelInput, XssDetectionModelOutput> _predictionEngine;

        public XssDetectionController()
        {
            _mlContext = new MLContext();
            InitializeModel().GetAwaiter().GetResult(); // Initialize the model asynchronously
        }

        // Asynchronous method to load and extract the model
        private async Task InitializeModel()
        {
            if (!System.IO.File.Exists(_modelPath))
            {
                throw new FileNotFoundException("XssDetectionModel.zip not found at path " + _modelPath);
            }

            // Unzip the model if it's not already extracted
            string extractedModelPath = Path.Combine(Path.GetDirectoryName(_modelPath), "extracted_model");
            if (!Directory.Exists(extractedModelPath))
            {
                Directory.CreateDirectory(extractedModelPath); // Ensure the directory exists
                ZipFile.ExtractToDirectory(_modelPath, extractedModelPath);
            }

            // Load the model (assuming it's in the zip file extracted into extracted_model directory)
            string modelFilePath = Path.Combine(extractedModelPath, "XssDetectionModel.zip");

            try
            {
                _model = _mlContext.Model.Load(modelFilePath, out var modelInputSchema);
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<XssDetectionModelInput, XssDetectionModelOutput>(_model);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException("Error loading the model", ex);
            }
        }

        // Endpoint to detect XSS in the input text
        [HttpPost("detect")]
        public IActionResult Detect([FromBody] XssDetectionModelInput input)
        {
            // Check for valid input
            if (input == null || string.IsNullOrEmpty(input.InputText))
            {
                return BadRequest("Input text is required.");
            }

            try
            {
                // Use the prediction engine to make a prediction
                var result = _predictionEngine.Predict(input);

                return Ok(new { IsMalicious = result.IsMalicious });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { Error = $"Error during prediction: {ex.Message}" });
            }
        }

        // Endpoint to retrain the model with new data
        [HttpPost("retrain")]
        public async Task<IActionResult> RetrainModel([FromBody] XssDetectionModelInput[] trainingData)
        {
            if (trainingData == null || trainingData.Length == 0)
            {
                return BadRequest("Training data is required.");
            }

            try
            {
                // Load the training data into an IDataView
                var dataView = _mlContext.Data.LoadFromEnumerable(trainingData);

                // Define the pipeline for retraining
                var pipeline = _mlContext.Transforms.Text.FeaturizeText("Features", nameof(XssDetectionModelInput.InputText))
                    .Append(_mlContext.BinaryClassification.Trainers.LbfgsLogisticRegression(labelColumnName: "IsMalicious", featureColumnName: "Features"));

                // Retrain the model
                var retrainedModel = pipeline.Fit(dataView);

                // Save the retrained model
                string retrainedModelPath = Path.Combine(Path.GetDirectoryName(_modelPath), "RetrainedModel.zip");
                _mlContext.Model.Save(retrainedModel, dataView.Schema, retrainedModelPath);

                // Update the model and prediction engine
                _model = retrainedModel;
                _predictionEngine = _mlContext.Model.CreatePredictionEngine<XssDetectionModelInput, XssDetectionModelOutput>(_model);

                return Ok(new { Message = "Model retrained successfully." });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { Error = $"Error during model retraining: {ex.Message}" });
            }
        }

        // Endpoint to evaluate the model's performance
        [HttpPost("evaluate")]
        public IActionResult EvaluateModel([FromBody] XssDetectionModelInput[] testData)
        {
            if (testData == null || testData.Length == 0)
            {
                return BadRequest("Test data is required.");
            }

            try
            {
                // Load the test data into an IDataView
                var dataView = _mlContext.Data.LoadFromEnumerable(testData);

                // Evaluate the model
                var predictions = _model.Transform(dataView);
                var metrics = _mlContext.BinaryClassification.Evaluate(predictions, "IsMalicious");

                return Ok(new
                {
                    Accuracy = metrics.Accuracy,
                    AUC = metrics.AreaUnderRocCurve,
                    F1Score = metrics.F1Score
                });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { Error = $"Error during model evaluation: {ex.Message}" });
            }
        }

        // Endpoint to get model version information
        [HttpGet("version")]
        public IActionResult GetModelVersion()
        {
            try
            {
                var modelVersion = _model.GetModelVersion();
                return Ok(new { Version = modelVersion });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { Error = $"Error retrieving model version: {ex.Message}" });
            }
        }

        // Endpoint to check model health
        [HttpGet("health")]
        public IActionResult CheckModelHealth()
        {
            try
            {
                // Perform a simple prediction to check if the model is working
                var testInput = new XssDetectionModelInput { InputText = "Test input" };
                var result = _predictionEngine.Predict(testInput);

                return Ok(new { Status = "Healthy", Message = "Model is functioning correctly." });
            }
            catch (Exception ex)
            {
                return StatusCode(500, new { Status = "Unhealthy", Error = $"Model health check failed: {ex.Message}" });
            }
        }
    }
}
