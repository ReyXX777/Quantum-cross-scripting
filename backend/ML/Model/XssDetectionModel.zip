using Microsoft.AspNetCore.Mvc;
using Microsoft.ML;
using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging; // Add logging
using System.Collections.Generic; // For storing evaluation metrics

namespace QuantumCrossScripting.ML.Model
{
    // ... (XssDetectionModelInput and XssDetectionModelOutput remain the same)

    [ApiController]
    [Route("[controller]")]
    public class XssDetectionController : ControllerBase
    {
        private readonly string _modelPath = "ML/Model/XssDetectionModel.zip";
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private PredictionEngine<XssDetectionModelInput, XssDetectionModelOutput> _predictionEngine;
        private readonly ILogger<XssDetectionController> _logger; // Logger

        public XssDetectionController(ILogger<XssDetectionController> logger) // Inject ILogger
        {
            _mlContext = new MLContext();
            _logger = logger; // Assign the injected logger
            InitializeModel().GetAwaiter().GetResult();
        }

        private async Task InitializeModel()
        {
           // ... (Model loading logic remains the same)
        }

        [HttpPost("detect")]
        public IActionResult Detect([FromBody] XssDetectionModelInput input)
        {
            // ... (Input validation remains the same)

            try
            {
                var result = _predictionEngine.Predict(input);
                _logger.LogInformation($"XSS Detection: Input='{input.InputText}', Result={result.IsMalicious}"); // Log detection
                return Ok(new { IsMalicious = result.IsMalicious });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during prediction."); // Log error
                return StatusCode(500, new { Error = $"Error during prediction: {ex.Message}" });
            }
        }

        [HttpPost("retrain")]
        public async Task<IActionResult> RetrainModel([FromBody] XssDetectionModelInput[] trainingData)
        {
            // ... (Retraining logic remains the same)
        }

        [HttpPost("evaluate")]
        public IActionResult EvaluateModel([FromBody] XssDetectionModelInput[] testData)
        {
            // ... (Input validation remains the same)

            try
            {
                var dataView = _mlContext.Data.LoadFromEnumerable(testData);
                var predictions = _model.Transform(dataView);
                var metrics = _mlContext.BinaryClassification.Evaluate(predictions, "IsMalicious");

                // Store metrics in a dictionary for more detailed reporting
                var evaluationMetrics = new Dictionary<string, double>
                {
                    { "Accuracy", metrics.Accuracy },
                    { "AUC", metrics.AreaUnderRocCurve },
                    { "F1Score", metrics.F1Score },
                    { "Precision", metrics.Precision }, // Added Precision
                    { "Recall", metrics.Recall }       // Added Recall
                };

                _logger.LogInformation("Model Evaluation: {@Metrics}", evaluationMetrics); // Log evaluation metrics

                return Ok(evaluationMetrics); // Return the dictionary
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error during model evaluation."); // Log error
                return StatusCode(500, new { Error = $"Error during model evaluation: {ex.Message}" });
            }
        }

        // ... (GetModelVersion and CheckModelHealth remain the same)
    }
}

